# Сервис баннеров (тестовое задание для стажёра Backend)

## Установка и запуск

```console
$ git clone https://github.com/cutehater/bannerservice.git && cd tasktracker
$ docker compose --profile production -p bannerservice build
$ docker compose --profile production -p bannerservice up
```

После выполнения данных команд сервис будет слушать на порту 8008. Пример запроса через curl:

```console
$ curl -X GET "http://localhost:8008/user_banner?tag_id=1&feature_id=2&use_last_revision=true" \
-H "token: user_token" \
-v
```

Для запуска интеграционных тестов достаточно поменять профиль сборки:

```console
$ docker compose --profile test -p bannerservice build
$ docker compose --profile test -p bannerservice up
```

## Вопросы и решения

### Стек

Сервис написан на Go c использованием фреймворка gin. В качестве базы данных используется PostgreSQL, для удобной работы с ней используется библиотека gorm. База данных для сервиса persistent (данные сохраняются на диске, так что их можно восстановить при падении инстанса БД), для тестов in-memory.

### Структура проекта

Поскольку проект совсем небольшой, я решила, что разумным будет хранить весь код плоско в корне проекта, без стандартного разделения на cmd, pkg, internal и т.д.

### Авторизация

Про авторизацию в задании было написано очень мало, но я решила, что будет слишком неправдоподобно, если я просто буду хранить две строки "user_token" и "admin_token" и проверять, прислали ли мне в хедере запроса одну из них. Поэтому я создала отдельную БД с пользователями, где хранится их токен и роль (админ/обычный пользователь). При инициализации базы данных туда добавляются "user_token" и "admin_token" из примера.

### Кэширование

Для того, чтобы не ходить на каждый пользовательский запрос в базу данных, я использовала expired in-memory кэш (для баннеров expiring time 5 минут, ключ tag_id+feature_id; для пользовательских токенов 1 час, ключ - сам токен). Для большей масштабируемости можно использовать LRU-cache с ограниченным размером (и тоже с expired записями). Тогда не будет проблемы, что кэш может слишком сильно переполниться, при этом редкие фичи/теги будут практически сразу "вылетать" из кеша, а те, к которым постоянно обращаются, жить до истечения своего expired time.

### Теги

Мне показалось странным, что тег — это сущность для обозначения группы пользователей, но при этом любой пользователь может получить данные по любому тегу. Пожалуй, по-хорошему надо бы создать ещё одну табличку в БД (с кэшированием) и делать проверку в запросе user_banner на то, принадлежит ли пользователь тегу. Но я решила, что про это в ТЗ совсем ничего нет и, возможно, я неправильно поняла и вообще оверкилл. В реальном мире я бы пошла и уточнила подробнее про эту часть.

### Тесты

Тесты интеграционные, создают фейковый сервер и посылают в него запросы с использованием библиотеки httptest. Проверяют примерно все стандартные сценарии работы с баннерами.